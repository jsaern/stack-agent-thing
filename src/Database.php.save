<?php
/**
 * Database.php
 *
 * @package default
 */

namespace Nrwtaylor\StackAgentThing;

ini_set('display_startup_errors', 1);
ini_set('display_errors', 1);
error_reporting(-1);

ini_set("allow_url_fopen", 1);

use Ramsey\Uuid\Uuid;
use Ramsey\Uuid\Exception\UnsatisfiedDependencyException;
use \PDO;

class Database
{
    public $var = 'hello';

    /**
     *
     * @param unknown $uuid
     * @param unknown $nom_from
     * @return unknown
     */
    function __construct($uuid, $nom_from)
    {
        $start_time = microtime(true);
        $this->start_time = $start_time;
        $this->split_time = $start_time;
        $this->operations_time = 0;
        $this->operations = 0;
        $this->log = array();

        // Database controls access by $uuid.

        // Should know $nom_from of requester.

        // Thing Database services.
        // "Without a name AND a uuid I'm not doing anything."
        // Which I started at 10.10am.

        // Basic Database should only be able to query multiple records
        // by $nom_from, or by the records which contain it's UUid.

        // So if $uuid is blank, that's okay. > Return matching
        // nom_from records.   And if $nom_from is blank
        // that's okay > Return matching uuid records.

        // The problem is when they are both null.
        // Code here should allow either.

        if ($nom_from == null and $uuid == null) {
            throw new Exception('No
			$nom_from and $uuid provided to Class Db.');
        }

        if ($nom_from == null) {
            throw new Exception('No $nom_from provided to
			Class Db.');
        }
        if ($uuid == null) {
            throw new Exception('No $uuid provided to
			Class Db.');
        }

        $this->from = $nom_from;
        $this->uuid = $uuid;

        // create container and configure it

        $settings = require $GLOBALS['stack_path'] . "private/settings.php";

        $this->web_prefix = $settings['settings']['stack']['web_prefix'];
        $this->state = $settings['settings']['stack']['state'];

        $this->container = new \Slim\Container($settings);

        // create app instance
        $app = new \Slim\App($this->container);
        $c = $app->getContainer();

        // Haven't seen this triggered.
        $c['errorHandler'] = function ($c) {
            return function ($request, $response, $exception) use ($c) {
                return $c['response']
                    ->withStatus(500)
                    ->withHeader('Content-Type', 'text/html')
                    ->write('AGENT | Maintenance.');
            };
        };

        $c['db'] = function ($c) {
            $db = $c['settings']['db'];
            $pdo = new PDO(
                "mysql:host=" . $db['host'] . ";dbname=" . $db['dbname'],
                $db['user'],
                $db['pass']
            );
            $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            $pdo->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
            return $pdo;
        };

        $c['stack'] = function ($c) {
            $db = $c['settings']['stack'];
            return $db;
        };

        $this->get_calling_function();
        //        $this->caller = $r;
        // $t[count($t)-2];

        $this->test("<b>" . $this->get_calling_function() . "</b>");

        // NRW Taylor 12 June 2018
        // devstack Database for to disk persistent memory calls, redis for in ram persistent calls

        $this->char_max = $c['stack']['char_max'];

        $this->uuid = $uuid;

        $this->test("Database set-up ");

        // Which means at this point, we have a UUID
        // whether or not the record exists is another question.

        // But we don't need to find, it because the UUID is randomly created.
        // Chance of collision super-super-small.

        // So just return the contents of thing.  false if it doesn't exist.

        $this->split_time = microtime(true);

        $r = "";

        return $r;
    }

    /**
     *
     */
    function __destruct()
    {
        // Log database transactions in test
        $this->test("Database destruct ");
    }

    /**
     *
     * @param unknown $comment     (optional)
     * @param unknown $instruction (optional)
     */
    function test($comment = null, $instruction = null)
    {
        if ($this->state != "test") {
            return;
        }

        if ($comment == null and $instruction == null) {
            $comment = "";
        }

        // devstack save to variable
        echo "<pre>";
        echo substr($this->uuid, 0, 4) . "-" . $this->caller . " ";
        echo str_pad(
            number_format((microtime(true) - $this->start_time) * 1000) . "ms",
            0,
            " ",
            STR_PAD_RIGHT
        );

        echo "[" . number_format($this->operations_time * 1e3) . "ms]";
        echo " " . $comment . " ";
        echo "split time " .
            number_format((microtime(true) - $this->split_time) * 1000) .
            "ms ";
        echo "operations " . $this->operations . " ";
        echo "<br>";

        foreach ($this->log as $key => $value) {
            echo str_pad("", 4, " ") . $value . "<br>";
        }
        $this->log = array();
        echo "</pre>";
    }

    /**
     *
     * @return unknown
     */
    function get_calling_function()
    {
        // see stackoverflow.com/questions/190421
        $caller = debug_backtrace();

        $caller = $caller[2];
        $r = $caller['function'] . '()';

        if (isset($caller['class'])) {
            $r .= ' called by ';
            // $r .= $caller['class'];
            $t = explode("\\", $caller['class']);
            $r .= "" . $t[count($t) - 1];
        }

        $this->caller = $t[count($t) - 1];

        $r .= "\\";
        $r .= debug_backtrace()[1]['function'];

        if (isset($caller['object'])) {
            //$r .= ' (' . get_class($caller['object']) . ')';
        }
        return $r;
    }

    /**
     *
     * @param unknown $created_at (optional)
     * @return unknown
     */
    function priorGet($created_at = null)
    {
        // Given a $uuid.  Find the previous record the $from user
        // created.

        // Review thought.  Wouldn't searching for the latest record
        // before the time_stamp be more efficient?

        // http://stackoverflow.com/questions/28451031/how-to-get-second-last-row-from-mysql-database
        // Doesn't work in case of same time_stamp.
        // That is acceptable.  A second resolution for creating records is
        // likely a good limit.  Easy to upgrade by adding a 'microsecond' column to the
        // database.

        // Change to InnoDB means stack is likely now working on microsecond
        // time quantum.

        // sqlinjection commentary
        // nom_from is a carrier provided identifier, therefore judged safe to
        // pass by message carriers.
        // created_at is a stack created field

        if ($created_at == null) {
            $query_string =
                "SELECT * FROM (SELECT * FROM stack WHERE
				nom_from='" .
                $this->from .
                "' ORDER BY created_at DESC LIMIT 2) AS t ORDER BY created_at ASC LIMIT 2";
        } else {
            $query_string =
                "SELECT * FROM stack where nom_from = '" .
                $this->from .
                "' and created_at < '" .
                $created_at .
                "' order by created_at DESC LIMIT 3";
        }
        try {
        $sth = $this->container->db->prepare($query_string);
        $sth->execute();
        $thing = $sth->fetchObject();
        } catch (\Exception $e) {
            // Devstack - decide how to handle thing full

//            $t = new Thing(null);
//            $t->Create("stack", "error", 'priorGet ' . $e->getMessage());
            $thing = false;
        }



        $thingreport = array(
            'thing' => $thing,
            'info' =>
                'Turns out it has an imperfect and forgetful memory.  But you can see what is on the stack by typing ' .
                $this->web_prefix .
                'api/thing/<32 characters>.',
            'help' => 'Check your junk/spam folder.'
        );

        // Runs in 0 to 8ms

        return $thingreport;
    }

    /**
     *
     * @param unknown $field_text
     * @param unknown $string_text
     */
    function writeField($field_text, $string_text)
    {
        $this->split_time = microtime(true);
        $this->log = array($field_text, $string_text);
        //$this->test( $this->get_calling_function() );

        // sqlinjection commentary
        // user provided string_text
        // stack provided field_text

        try {
            $query = "UPDATE stack SET $field_text=:string_text WHERE uuid=:uuid";
            $sth = $this->container->db->prepare($query);

            $sth->bindParam(":uuid", $this->uuid);
            $sth->bindParam(":string_text", $string_text);

            // This is not allowed by PHP.
            // Noting that field_text is generated by an Agent.  Not channel input.
            //$sth->bindParam(":field_text", $field_text);

            $sth->execute();

            $this->last_update = false;
        } catch (\Exception $e) {
            // Devstack - decide how to handle thing full
            // Do this for now.

//            $t = new Thing(null);
//            $t->Create('stack', "error", 'writeField ' . $e->getMessage());


            // Commented out 24 November 2019.
            // Prevents a SQLSTATE[22001] error from looping.
            //$t = new Bork($t);

            //echo "BORK | Thing is full.";
            //echo 'Caught error: ',  $e->getMessage(), "\n";
            $thing = false;
            $this->last_update = true;
        }

        $this->operations_time += microtime(true) - $this->split_time;
        $this->operations += 1;
        //$this->test("writeField");
    }

    /**
     *
     * @return unknown
     */
    function count()
    {
        $sth = $this->container->db->prepare("SELECT count(*) FROM stack");
        $sth->execute();

        $thing_count = $sth->fetchColumn();

        $thingreport = array(
            'things' => false,
            'info' => 'Counted ' . $thing_count . '  records on stack.',
            'help' => 'This is how big the stack is.'
        );
        $thingreport['number'] = $thing_count;

        return $thingreport;
    }

    /**
     *
     * @param unknown $field
     * @return unknown
     */
    function readField($field)
    {
        $thingreport = $this->Get();
        $this->thing = $thingreport['thing'];

        if (isset($this->thing->$field)) {
            // I think I should also do
            $this->$field = $this->thing->$field;
            return $this->thing->$field;
        } else {
            return false;
        }
    }

    /**
     *
     * @param unknown $subject
     * @param unknown $to
     * @return unknown
     */
    function Create($subject, $to)
    {

        try {
        // Create a new record in the db for the Thing.
        $this->split_time = microtime(true);

        //$this->test("Create");

        $query = $this->container->db->prepare("INSERT INTO stack
			(uuid,task,nom_from,nom_to)
			VALUES (:uuid, :task, :nom_from, :nom_to)");

        $query->bindParam(':uuid', $uuid);
        $query->bindParam(':task', $task);
        $query->bindParam(':nom_from', $nom_from);
        $query->bindParam(':nom_to', $nom_to);

        $uuid = $this->uuid;
        $task = $subject;
        $nom_from = $this->from;
        $nom_to = $to;

        $query->execute();

        return $query;

        } catch (\Exception $e) {
            // Devstack - decide how to handle thing full
            // Do this for now.

//            $t = new Thing(null);
//            $t->Create("stack", "error", 'Create' . $e->getMessage());


            // Commented out 24 November 2019.
            // Prevents a SQLSTATE[22001] error from looping.
            //$t = new Bork($t);

            //echo "BORK | Thing is full.";
            //echo 'Caught error: ',  $e->getMessage(), "\n";
            $thing = false;
            $this->last_update = true;
            return false;

        }


    }

    /**
     *
     * @return unknown
     */
    function Get()
    {
        // But we don't need to find, it because the UUID is randomly created.
        // Chance of collision super-super-small.

        // So just return the contents of thing.  false if it doesn't exist.

        try {
            // Trying long form.  Doesn't seme to have performance advantage.
            $sth = $this->container->db->prepare(
                "SELECT uuid, task, nom_from, nom_to, created_at, associations, message0, message1, message2, message3, message4, message5, message6, message7, settings, variables FROM stack WHERE uuid=:uuid"
            );

            //$sth = $this->container->db->prepare("SELECT * FROM stack WHERE uuid=:uuid");
            $sth->bindParam("uuid", $this->uuid);
            $sth->execute();
            $thing = $sth->fetchObject();
        } catch (\Exception $e) {

// devstack look get the error code.
// SQLSTATE[HY000] [2002] Connection refused
if (($e->getCode() == '2002') or ($e->getCode() =='HY000')) {

// devstack write to text file?
// Don't try making more entries when the database is refusing entries...


} else {
//            $t = new Thing(null);
//            $t->Create("stack", "error", 'Get ' . $e->getCode());
}

            $thing = false;
        }

        $thingreport = array(
            'thing' => $thing,
            'info' =>
                'Turns out it has an imperfect and forgetful memory.  But you can see what is on the stack by typing ' .
                $this->web_prefix .
                'api/thing/<32 characters>.',
            'help' => 'Check your junk/spam folder.'
        );

        $this->test();

        return $thingreport;
    }

    /**
     *
     * @return unknown
     */
    function Forget()
    {
        $sth = $this->container->db->prepare(
            "DELETE FROM stack WHERE uuid=:uuid"
        );
        $sth->bindParam("uuid", $this->uuid);
        $sth->execute();

        $thingreport = array('info' => 'That thing was forgotten.');
        return $thingreport;
    }

    /**
     *
     * @param unknown $id (optional)
     */
    function setUser($id = null)
    {
        if ($id == null) {
            $id = "null@" . $settings['settings']['stack']['mail_postfix'];
        }
        $this->from = $id;
        return;
    }

    /*
    // Add bindparam
	function userRecords($user_search, $limit = null)
    {

		if ($limit == null) {$limit = 3;}

		$user_search = $this->from;
		$query = "SELECT * FROM stack WHERE nom_from LIKE '%$user_search%' ORDER BY created_at DESC LIMIT $limit";

		$sth = $this->container->db->prepare($query);

		$sth->execute();
		$things = $sth->fetchAll();

		$thingreport = array('thing' => $things, 'info' => 'So here are three things you put on the stack.  That\'s what you wanted.','help' => 'It is up to you what you do with these.');

		return $thingreport;
	}
*/

    /**
     *
     * @param unknown $nom_from
     */
    function setFrom($nom_from)
    {
        $this->from = $nom_from;
        return;
    }

    /**
     *
     * @param unknown $value
     * @param unknown $max   (optional)
     * @return unknown
     */
    function associationSearch($value, $max = null)
    {
        if ($max == null) {
            $max = 3;
        }
        $max = (int) $max;

        $user_search = $this->from;

        // https://stackoverflow.com/questions/11068230/using-like-in-bindparam-for-a-mysql-pdo-query
        $value = "%$value%"; // Value to search for in Variables
        //      $value = "*$value*"; // Value to search for in Variables

        //        $max = (int) $max;

        $thingreport['things'] = array();

        try {
            $value = "%$value%"; // Value to search for in Variables
            $query =
                "SELECT * FROM stack WHERE nom_from=:user_search AND associations LIKE :value ORDER BY created_at DESC LIMIT :max";
            // $query = "SELECT * FROM stack WHERE nom_from=:user_search AND MATCH(variables) AGAINST(:value IN BOOLEAN MODE ) ORDER BY creat$
            // $query = "SELECT * FROM stack WHERE nom_from=:user_search AND MATCH(variables) AGAINST(:value IN BOOLEAN MODE ) ORDER BY creat$
            // $query = "SELECT uuid, task, nom_from, nom_to, created_at, message0, settings, variables FROM stack WHERE nom_from=:user_searc$

            // $value = "*$value*"; // Value to search for in Variables
            // $query = "SELECT uuid, variables FROM stack WHERE nom_from=:user_search AND MATCH(variables) AGAINST(:value IN BOOLEAN MODE ) $

            $sth = $this->container->db->prepare($query);

            $sth->bindParam(":user_search", $user_search);
            $sth->bindParam(":value", $value);
            $sth->bindParam(":max", $max, PDO::PARAM_INT);
            $sth->execute();

            $things = $sth->fetchAll();

            $thingreport['info'] =
                'So here are Things with the association you provided. That\'s what you want';
            $thingreport['things'] = $things;
        } catch (\PDOException $e) {
//            $t = new Thing(null);
//            $t->Create("stack", "error", 'associationSearch ' .$e->getMessage());

            // echo "Error in PDO: ".$e->getMessage()."<br>";
            $thingreport['info'] = $e->getMessage();
            $thingreport['things'] = [];
        }

        return $thingreport;
    }

    /**
     *
     * @param unknown $path
     * @param unknown $value
     * @param unknown $max   (optional)
     * @return unknown
     */
    function variableSearch($path, $value, $max = null)
    {
        if ($max == null) {
            $max = 3;
        }
        $max = (int) $max;

        $user_search = $this->from;

        // https://stackoverflow.com/questions/11068230/using-like-in-bindparam-for-a-mysql-pdo-query
        $value = "%$value%"; // Value to search for in Variables
        //      $value = "*$value*"; // Value to search for in Variables

        //        $max = (int) $max;

        $thingreport['things'] = array();

        try {
            //            $value = "%$value%"; // Value to search for in Variables
            $query =
                "SELECT * FROM stack WHERE nom_from=:user_search AND variables LIKE :value ORDER BY created_at DESC LIMIT :max";
            // $query = "SELECT * FROM stack WHERE nom_from=:user_search AND MATCH(variables) AGAINST(:value IN BOOLEAN MODE ) ORDER BY created_at DESC LIMIT :max";
            // $query = "SELECT * FROM stack WHERE nom_from=:user_search AND MATCH(variables) AGAINST(:value IN BOOLEAN MODE ) ORDER BY created_at DESC LIMIT :max";
            // $query = "SELECT uuid, task, nom_from, nom_to, created_at, message0, settings, variables FROM stack WHERE nom_from=:user_search AND MATCH(variables) AGAINST(:value IN BOOLEAN MODE ) ORDER BY created_at DESC LIMIT :max";

            // $value = "*$value*"; // Value to search for in Variables
            // $query = "SELECT uuid, variables FROM stack WHERE nom_from=:user_search AND MATCH(variables) AGAINST(:value IN BOOLEAN MODE ) ORDER BY created_at DESC LIMIT :max";

            $sth = $this->container->db->prepare($query);

            $sth->bindParam(":user_search", $user_search);
            $sth->bindParam(":value", $value);
            $sth->bindParam(":max", $max, PDO::PARAM_INT);
            $sth->execute();

            $things = $sth->fetchAll();

            $thingreport['info'] =
                'So here are Things with the variable you provided in \$variables. That\'s what you want';
            $thingreport['things'] = $things;
        } catch (\PDOException $e) {
            // echo "Error in PDO: ".$e->getMessage()."<br>";
            $thingreport['info'] = $e->getMessage();
            $thingreport['things'] = [];
        }

        return $thingreport;
    }

    /**
     *
     * @param unknown $agent
     * @param unknown $max   (optional)
     * @return unknown
     */
    function testSearch($keyword_input)
    {
        $query =
            'SELECT * FROM stack WHERE task="something something something"';

        $sth = $this->container->db->prepare($query);

        try {
            $sth->execute();
        } catch (\PDOException $e) {
//            $t = new Thing(null);
//            $t->Create("stack", "error", 'testSearch ' . $e->getMessage());
        }
        $things = $sth->fetchAll();
        //        $thingreport = array('things' => $things, 'info' => 'So here are Things with the phrase you provided in \$variables. That\'s what y$
        $thingreport = array(
            'things' => $things,
            'info' =>
                'So here are Things with the phrase you provided in \$variables. That\'s what you wanted.',
            'help' => 'It is up to you what you do with these.',
            'whatisthis' =>
                'A list of Things which match at the provided phrase.'
        );

        return $thingreport;
    }

    /**
     *
     * @param unknown $agent
     * @param unknown $max   (optional)
     * @return unknown
     */
    function subjectSearch($keyword_input, $agent, $max, $mode = null)
    {
        $user_search = $this->from;
        //        $keyword = "%$keyword%"; // Value to search for in Variables
        //        $keyword = '"' . $keyword .'"'; // Value to search for in Variables
        //$keyword = "$keyword";

        //$keyword = $this->container->db->quote($keyword_input);

        if ($max == null) {
            $max = 3;
        }
        $max = (int) $max;

        if ($mode == null or strtolower($mode) == "boolean") {
            $keyword = $this->container->db->quote($keyword_input);
            $query =
                'SELECT * FROM stack WHERE nom_from=:user_search AND nom_to=:agent AND MATCH(task) AGAINST (:keyword IN BOOLEAN MODE) ORDER BY created_at DESC LIMIT :max';
        }

        if (strtolower($mode) == "like") {
            $keyword = "$keyword_input"; // Value to search for in Variables
            $query =
                'SELECT * FROM stack WHERE task LIKE BINARY :keyword AND nom_to=:agent AND nom_from=:user_search ORDER BY created_at DESC LIMIT :max';
        }
        if (strtolower($mode) == "where") {
            $keyword = $this->container->db->quote($keyword_input);
            $query =
                'SELECT * FROM stack WHERE task = BINARY :keyword AND nom_to=:agent AND nom_from=:user_search ORDER BY created_at DESC LIMIT :max';
        }

        if (strtolower($mode) == "natural language") {
            $keyword = $this->container->db->quote($keyword_input);
            $query =
                'SELECT * FROM stack WHERE nom_from=:user_search AND nom_to=:agent AND MATCH(task) AGAINST (:keyword IN NATURAL LANGUAGE MODE) ORDER BY created_at DESC LIMIT :max';
        }

        if (strtolower($mode) == "equal") {
            $keyword =
                "adidas adiPower S bounce men\'s spikeless Golf Shoe NEW";
            //      $keyword = $keyword_input; // Value to search for in Variables
            $keyword = $this->container->db->quote(
                "adidas adiPower S bounce men\'s spikeless Golf Shoe NEW"
            );

            $keyword = '$keyword_input';
         //           $keyword = $this->container->db->quote($keyword_input);
            //$text = "adidas adiPower S bounce men's spikeless Golf Shoe NEW";
            //  $query ='SELECT * FROM stack WHERE task=:keyword AND nom_to=:agent AND nom_from=:user_search ORDER BY created_at DESC LIMIT :max';

            $query = 'SELECT * FROM stack WHERE task=":keyword"';
        }

        $sth = $this->container->db->prepare($query);
        $sth->bindParam(":user_search", $user_search);
        $sth->bindParam(":keyword", $keyword);
        $sth->bindParam(":agent", $agent);
        $sth->bindParam(":max", $max, PDO::PARAM_INT);

        try {
            $sth->execute();
        } catch (\PDOException $e) {
//            $t = new Thing(null);
//            $t->Create("stack", "error", 'subjectSearch ' .$e->getMessage());

//            echo 'Caught exception: ', $e->getMessage(), "\n";
        }
        $things = $sth->fetchAll();
