<?php
namespace Nrwtaylor\StackAgentThing;

class Pace
{
    // Starting point for a channel pace setting support.

    // Provide start time.
    // And runtime.
    // And a set of indexes.

    // An exercise in augemented virtual collaboration. With water.
    // But a Thing needs to know what minding the gap is.

	public $var = 'hello';

    // This will provide a pace - a unit of energy converted into a paced unit of distance.
    // This is useful for PACE because it is the first step in provided the distance travelled down a path.
    // When provided with a random time interval series of energy inputs.

    // See getEnergy() for dev

    function __construct(Thing $thing, $agent_input = null)
    {
        // Precise timing
        $this->start_time = $thing->elapsed_runtime();

        $this->agent_input = $agent_input;
		$this->thing = $thing;

        $this->thing_report['thing'] = $thing;
        $this->agent_name = "pace";

		$this->retain_for = 24; // Retain for at least 24 hours.

        $this->uuid = $thing->uuid;
      	$this->to = $thing->to;
       	$this->from = $thing->from;
       	$this->subject = $thing->subject;
		$this->sqlresponse = null;

        $this->state = "dev";

		$this->thing->log( 'running on Thing ' . $this->thing->nuuid . '.');
		$this->thing->log( 'received this Thing "' . $this->subject . '"');
        $this->thing->log( 'received this Agent Input "' . $this->subject . '"');



        // Get some stuff from the stack which will be helpful.
        // Until PACE gets its own.
        $this->web_prefix = $thing->container['stack']['web_prefix'];
        $this->mail_postfix = $thing->container['stack']['mail_postfix'];
        $this->word = $thing->container['stack']['word'];
        $this->email = $thing->container['stack']['email'];

        $this->time_travel_unit_name = "s";
        $this->time_unit_name = "seconds";

        $this->get(); // load in last known position variables for current player

		$this->readSubject();

        $this->doPace();

		$this->respond();

        if ($this->agent_input != "pace") {
        $this->set();
        }
		$this->thing->log( 'completed.');

        //echo $this->thing->elapsed_runtime() - $this->start_time;


		return;
    }

    // Add in code for setting the current distance travelled.
    function set()
    {
        // UK Commonwealth spelling
        $this->thing->json->setField("variables");
        $names = $this->thing->json->writeVariable( array("pace", "time_travelled"), $this->time_travelled );

        $time_string = $this->thing->time();
        $this->thing->json->writeVariable( array("pace", "refreshed_at"), $time_string );

        $pace_timestamp = $this->thing->microtime();
        $this->thing->json->writeVariable( array("pace", "timestamp"), $pace_timestamp );
    }

    function get()
    {
        $this->thing->json->setField("variables");
        $time_string = $this->thing->json->readVariable( array("pace", "refreshed_at") );

        $micro_timestamp = $this->thing->json->readVariable( array("pace", "timestamp") );

        // Keep second level timestamp because I'm not
        // sure Stackr can deal with microtimes (yet).
        if ($time_string == false) {
            $time_string = $this->thing->json->time();
            $this->thing->json->writeVariable( array("pace", "refreshed_at"), $time_string );
        }

        // And in microtime code for Pace.
        if ($micro_timestamp == false) {
            $micro_timestamp = $this->thing->microtime();
            $this->thing->json->writeVariable( array("pace", "timestamp"), $micro_timestamp );
        }


        // If it has already been processed ...
        $this->last_timestamp = $micro_timestamp;


        $this->time_travelled = $this->thing->json->readVariable( array("pace", "time_travelled") );
        $this->response = "Loaded Pace time travelled and microsecond timestamp."; // Because
    }

    // -----------------------
	private function respond()
    {
		$this->thing->flagGreen();

		// This should be the code to handle non-matching responses.

		$to = $this->thing->from;
		$from = "pace";

        $this->makeMessage();
        $this->makeSms();

        if ($this->agent_input == null) {
            $message_thing = new Message($this->thing, $this->thing_report);
		    $this->thing_report['info'] = $message_thing->thing_report['info'] ;
        }

        $this->makeWeb();


        $this->thing_report['sms'] = $this->sms_message;

		return $this->thing_report;
	}

    private function paceDo()
    {
        // What does pace do. doPace is doing a Pace.

        // Pace is a tool to connect to our world.  Welcome.

        // What open source means is that everybody can read and see our code.
        // Because you need to share.  So do we.

        // See Github: nrwtaylor/stack-agent-thing

        // A Pace is a unified step of time measured from you.
        // A Pace is a unit of energy.  It happens to be exactly the same as a metric calorie.
        // Weird. Again.



        // And then Pace figures out how for that energy would have got you along your path.

        // Welcome to <Insert Robot Name Here>.  The Robot Coxswain.

        // Yeah we want to steer the path too.  But this is Pace.  
        // For Pacers.

        // If you don't want to worry about where you are going, don't worry about <Insert Robot Name Here>.

        // Code?

        // Sure.

        $this->getEnergy();

        

    }

    public function lastPace()
    {
        $this->getTime();

        $findagent_thing = new FindAgent($this->thing, 'pace');

        $this->thing->log('Agent "Pace" found ' . count($findagent_thing->thing_report['things']) ." Pace Agent Things." );

        $this->last_created_at =  $findagent_thing->thing_report['things'][0]['created_at'];
    }

    public function doPace()
    {
        // What is to do a Pace.

        // This will be the full cycle of a Pace.

        // Pace.

        // For now take unit of energy and convert it into distance travelled.
        $this->energy_number = 1;


        $time_travelled = $this->paceEnergy($this->energy_number);

        $this->getTime();

        $this->max_tick_time = 60*4; // Four minutes

        if ($this->tick_time > $this->max_tick_time) {
            $this->flag = new Flag($this->thing, "red");
        }


        // I think a Pace is not the catching a prompt.

    }

    private function paceEnergy($energy_text = null)
    {
        if ($energy_text == null) {$energy_text = $this->energy->number;}

        $scalar = 0;
        $this->velocity = 0;
        $this->velocity = -1; // m/s test current
        $this->acceleration = 0;

        // Realworld elapsed time
        //$tick_time = 534 / 1000; // ms > s

        $this->tick_time = $this->getTime(); //s but test

//        $this->time_travelled += $this->tick_time;
        $this->time_travelled = $this->tick_time;

        return $this->time_travelled;

    }



    public function getTime()
    {
        if (isset($this->elapsed_clock)) {return $this->elapsed_clock;}
        // Only do this once.
        // Can't have calculations based on different timestamps.
        if (!isset($this->current_timestamp)) {$this->current_timestamp = $this->thing->microtime();}

        //$this->current_timestamp = $this->thing->microtime();
        $this->elapsed_clock = $this->microtime_diff($this->last_timestamp, $this->current_timestamp);
        return $this->elapsed_clock;
    }

    // https://gist.github.com/hadl/5721816
    function microtime_diff($start, $end)
    {
        // Lots of testing needed on this :/
        // Date maths.  Urgh.

        list($start_date, $start_clock, $start_usec) = explode(" ", $start);
        list($end_date, $end_clock, $end_usec) = explode(" ", $end);

        $diff_date = strtotime($end_date) - strtotime($start_date);

        $diff_clock = strtotime($end_clock) - strtotime($start_clock);

        $diff_usec = floatval($end_usec) - floatval($start_usec);

        return floatval($diff_date) + floatval($diff_clock) + $diff_usec;
    }

/**
 * Format an interval to show all existing components.
 * If the interval doesn't have a time component (years, months, etc)
 * That component won't be displayed.
 *
 * @param DateInterval $interval The interval
 *
 * @return string Formatted interval string.
 */
function format_interval(DateInterval $interval) {
    $result = "";
    if ($interval->y) { $result .= $interval->format("%y years "); }
    if ($interval->m) { $result .= $interval->format("%m months "); }
    if ($interval->d) { $result .= $interval->format("%d days "); }
    if ($interval->h) { $result .= $interval->format("%h hours "); }
    if ($interval->i) { $result .= $interval->format("%i minutes "); }
    if ($interval->s) { $result .= $interval->format("%s seconds "); }
//var_dump($interval);
//exit();
    return $result;
}

    private function getEnergy()
    {
        // Insert code to talk to Concept2.  
        $text = "Nonsense text string, json string, or other text representation of 1 energy units";

        // Going to be a call from a peeple for a pace.  So it should be provided.
        // So retrieve the pace energy last posted.
        // Call that a custom Pace function to read and write the energy to a pace variable.
        $this->energy = new Number($this->thing, "energy " . $text); // test uniqueness?

        // Which means we now have 
    }

	public function readSubject()
    {

        if ($this->agent_input == "pace") {$this->lastPace(); return;}

        $input = strtolower($this->subject);

        $this->response = "The robot needs the word.";
        if (strpos($input, 'amalgamate') !== false) {
            $this->response = "Thanks for the word.";
            return;
        }

        $number_agent = new Number($this->thing, "number");
	var_dump($number_agent->numbers);

	$this->min = 1;
	$this->max = 1;
	if (count($number_agent->numbers) == 1) {
		$this->max = $number_agent->numbers[0];
	}

        if (count($number_agent->numbers) == 2) {
                $this->min = min($number_agent->numbers[0], $number_agent->numbers[1]);
                $this->max = max($number_agent->numbers[0], $number_agent->numbers[1]);

        }


        $runtime_agent = new Runtime($this->thing, "runtime");
        $item_count = $this->max - $this->min + 1;
        $this->per_item_time = ((float)$runtime_agent->minutes / (float)$item_count);

//        $runat_agent = new Runat($this->thing, "runat");
//        $this->run_at_hour = $runat_agent->hour;
//        $this->run_at_minute = $runat_agent->minute;

        // Build current time
	// Build time entity
	// Now?  Or next?
$this->getTime();
var_dump($this->current_timestamp);

$date = explode(" ", $this->current_timestamp)[0];
$time = explode(" ", $this->current_timestamp)[1]; 

//$seconds = seconds($time);
//var_dump($seconds);

// + explode(" ", $this->current_timestamp)[2];
var_dump($date);
var_dump($time);

//$current_time = (strtotime($date . " " . $time));
$current_date = date_create($date . " " . $time);
var_dump($current_date);

// Build run at time

        $runat_agent = new Runat($this->thing, "runat");
        $this->run_at_hour = $runat_agent->hour;
        $this->run_at_minute = $runat_agent->minute;

//var_dump(hour($current_time));
//var_dump($this->run_at_minute);
//var_dump($this->run_at_hour);

$runat_date = date_create($date . " " . $this->run_at_hour.":".$this->run_at_minute);

$runend_date = clone $runat_date;

//var_dump($runtime_agent->minutes);
$runend_date = date_add($runend_date, date_interval_create_from_date_string($runtime_agent->minutes . " minutes"));
//$runend_date = date_add($runend_date, date_interval_create_from_date_string("55 minutes"));

if ($runend_date < $current_date) {
date_add($runat_date, date_interval_create_from_date_string("1 day"));
date_add($endat_date, date_interval_create_from_date_string("1 day")); 
}

var_dump($runat_date);
var_dump($runend_date);

//$interval = $runat_date->diff($runend_date);
$this->runtime = $runend_date->getTimestamp() - $runat_date->getTimestamp();
$this->elapsed = $current_date->getTimestamp() - $runat_date->getTimestamp();
$this->togo = $this->runtime - $this->elapsed;

$this->percent = $this->elapsed / $this->runtime;

$this->runat_date = $runat_date;
$this->runend_date = $runend_date;

var_dump($this->elapsed);

var_dump($this->togo);
var_dump($this->percent);

var_dump($this->min);
var_dump($this->max);

$this->items_ghost = ($this->max - $this->min) * $this->percent + $this->min;


		$this->response = "Paced.";
		//$this->sms_message = "SPLOSH | https://dictionary.cambridge.org/dictionary/english/splosh";
		$this->message = "https://www.urbandictionary.com/define.php?term=pace";
		$this->keyword = "pace";

		$this->thing_report['keyword'] = $this->keyword;
//		$this->thing_report['sms'] = $this->sms_message;
		$this->thing_report['email'] = $this->message;


        $this->paceDo();


		return $this->response;
	}

    public function makeSms()
    {
        $link = $this->web_prefix . 'thing/' . $this->uuid . '/pace';

        if ((!isset($this->tick_time)) or ($this->tick_time == 0)) {
            $sms = "PACE ";
        } else {
            //$sms = "PACED " . $this->thing->human_time($this->tick_time);
            $sms = "PACE";

        }

        $link = "";
	$this->response = $this->per_item_time . " minutes";

$percent = (intval($this->percent*100));

        $progress_text = " " . $percent . "% " . "item " . intval($this->items_ghost) . " of " . ($this->max-$this->min + 1) . " items.";

        if ($this->min != 1) {
        $progress_text = " " . $percent . "% " . "item " . intval($this->items_ghost);
        }

	if ($this->max == $this->min) {
        $progress_text = " " . $percent . "% complete.";
	}



        $this->response .= $progress_text;
	$this->response .= " " . $this->thing->human_time($this->togo) . " to go.";

//$interval = $runat_date->diff($runend_date);
//$this->runtime = $runend_date->getTimestamp() - $runat_date->getTimestamp();
//$this->elapsed = $current_date->getTimestamp() - $runat_date->getTimestamp();
//$this->togo = $runtime - $elapsed;

//$percent = $elapsed / $runtime;
//var_dump($this->elapsed);

//var_dump($this->togo);
//var_dump($this->percent);

//var_dump($this->min);
//var_dump($this->max);

//$this->items_ghost = ($this->max - $this->min) * $this->percent + $this->min;



        //$sms .= " | https://www.urbandictionary.com/define.php?term=pace";
//        $sms .= " | " . $link . " | " . $this->response;
        $sms .= " | " . $this->response;


        $this->sms_message = $sms;
        $this->thing_report['sms'] = $this->sms_message;
    }

    public function makeMessage()
    {
        $link = $this->web_prefix . 'thing/' . $this->uuid . '/pace';

        if ((!isset($this->tick_time)) or ($this->tick_time == 0)) {
            $message = "Pace ";
        } else {
            $message = "Paced off for " . $this->thing->human_time($this->tick_time) .".";
        }

        //$sms .= " | https://www.urbandictionary.com/define.php?term=pace";
        //$sms .= " | " . $link . " | " . $this->response;

        $this->message = $message;
        $this->thing_report['message'] = $message;
    }


    public function makeWeb()
    {

        $link = $this->web_prefix . 'thing/' . $this->uuid . '/pace';

        $flag = "";
        if (isset($this->flag->state)) {
            $flag = $this->flag->state;
        }

        $html = "<b>PACE " . $flag;
        $html = "</b>";
        


        $html .= "<p><b>Pace Variables</b>";
        //$html .= '<br>state ' . $this->state . '';

        //$html .= "<br>Distance just sploshed is " . $this->distance_travelled . $this->distance_unit_name;
        //$html .= "<br>Total distance sploshed " . $this->distance . $this->distance_unit_name;

        $elapsed_time_between_paces = $this->elapsed_clock * 1e3; // To convert to seconds

        // $html .= "<br>Elapsed time between paces " . $this->elapsed_clock * 1e3 . $this->time_unit_name;

        $html .= "<br>Pace time " . $this->thing->human_time($this->elapsed_clock);

        $html .= "<br>Time travelled " . $this->thing->human_time($this->time_travelled); // Commonwealth spelling
        $html .= " (" . number_format(intval($this->time_travelled)) . "s)."; // Commonwealth spelling

        // You can hardcode you Splosh page here
        $html .= "<p><b>Pace-Pacer link</b>";
        $html .= "<br>";

        $html .= '<a href="' . $link . '">';
//        $web .= $this->html_image;
        $html .= $link;

        $html .= "</a>";
        $html .= "<br>";
        $html .= "<br>";
        $html .= 'Pace says, "';
        $html .= $this->message. '"';


        $warranty = new Warranty($this->thing, "warranty");

        $html .= "<p><br>" . "This is a developmental tool. Sometimes it might not work. If you have resources, we hope you can make it more reliable.";

        $html .= "<p><br>" . "Thank you for your recent pace. " . $warranty->message;

//exit();

        $html .= "<p>";
        $html .= "<br>Last pace time " . $this->last_timestamp;



    //$html .= "<br>Check-in was " . intval($this->time_travelled) . "ms ago."; // Commonwealth spelling



        $this->web_message = $html;
        $this->thing_report['web'] = $this->web_message;
    }





}
